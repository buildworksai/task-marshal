/**
 * Marshal Tasks Tool - Core Task Orchestration
 * BuildWorks.AI - Intelligent task management with filesystem persistence, subtasks, and dependencies
 * 
 * Note: This class is used by the MCP server but not directly imported to avoid circular dependencies
 */

import { Tool } from '@modelcontextprotocol/sdk/types.js';
import { v4 as uuidv4 } from 'uuid';
import winston from 'winston';
import { 
  TaskMarshalConfig, 
  MarshalTasksParams, 
  TaskMarshalResponse,
  NotFoundError,
  ValidationError
} from '../types/index.js';
import { ValidationUtils } from '../utils/validation.js';
import { AuditLogger } from '../utils/audit.js';
import { FilesystemManager } from '../utils/filesystem.js';
import { JournalManager } from '../utils/journal.js';
import { DependencyManager } from '../utils/dependencies.js';
import { Task, Initiative, DependencyContract, Subtask } from '../types/enhanced.js';

/**
 * Marshal Tasks Tool - Core task orchestration with filesystem persistence
 */
export class MarshalTasksTool {
  private _config: TaskMarshalConfig;
  private _logger: winston.Logger;
  private _auditLogger: AuditLogger;
  private filesystem: FilesystemManager;
  private journal: JournalManager;
  private dependencies: DependencyManager;
  private rollbackMode: boolean = false;

  constructor(
    config: TaskMarshalConfig,
    logger: winston.Logger,
    auditLogger: AuditLogger
  ) {
    this._config = config;
    this._logger = logger.child({ tool: 'marshal_tasks' });
    this._auditLogger = auditLogger;
    
    const signingKey = process.env.TASK_MARSHAL_SIGNING_KEY || 'default-key';
    this.filesystem = new FilesystemManager({
      rootDir: process.env.TASK_MARSHAL_DATA_DIR || '.taskmarshal',
      signingKey
    });
    this.journal = new JournalManager();
    this.dependencies = new DependencyManager();
  }

  /**
   * Enable rollback mode - use in-memory storage only
   */
  enableRollbackMode(): void {
    this.rollbackMode = true;
    this._logger.warn('Rollback mode enabled - using in-memory storage');
  }

  /**
   * Get tool definition for MCP
   */
  getToolDefinition(): Tool {
    return {
      name: 'marshal_tasks',
      description: 'Intelligent task management with natural language processing, smart categorization, and automated prioritization. Create, update, assign, and analyze tasks with AI-powered features.',
      inputSchema: {
        type: 'object',
        properties: {
          action: {
            type: 'string',
            enum: ['create', 'update', 'assign', 'complete', 'analyze', 'list'],
            description: 'The action to perform on tasks'
          },
          task: {
            type: 'object',
            description: 'Task data for create/update operations',
            properties: {
              title: { type: 'string', description: 'Task title' },
              description: { type: 'string', description: 'Task description' },
              priority: { 
                type: 'string', 
                enum: ['low', 'medium', 'high', 'critical'],
                description: 'Task priority level'
              },
              assignee: { type: 'string', description: 'User ID of assignee' },
              dueDate: { type: 'string', format: 'date-time', description: 'Task due date' },
              tags: { 
                type: 'array', 
                items: { type: 'string' },
                description: 'Task tags for categorization'
              },
              projectId: { type: 'string', description: 'Associated project ID' },
              dependencies: {
                type: 'array',
                items: { type: 'string' },
                description: 'Task dependency IDs'
              }
            }
          },
          naturalLanguage: {
            type: 'string',
            description: 'Natural language description for AI-powered task creation. Example: "Create a high-priority bug fix task for the authentication module, assign to the security team, due by end of week"'
          },
          sessionId: {
            type: 'string',
            description: 'Session ID for tracking and context'
          },
          filters: {
            type: 'object',
            description: 'Filters for task listing and analysis',
            properties: {
              status: {
                type: 'array',
                items: { type: 'string', enum: ['pending', 'in-progress', 'completed', 'cancelled'] }
              },
              priority: {
                type: 'array',
                items: { type: 'string', enum: ['low', 'medium', 'high', 'critical'] }
              },
              assignee: { type: 'array', items: { type: 'string' } },
              projectId: { type: 'array', items: { type: 'string' } },
              tags: { type: 'array', items: { type: 'string' } },
              dueDate: {
                type: 'object',
                properties: {
                  from: { type: 'string', format: 'date-time' },
                  to: { type: 'string', format: 'date-time' }
                }
              }
            }
          },
          limit: {
            type: 'number',
            minimum: 1,
            maximum: 100,
            default: 20,
            description: 'Maximum number of tasks to return'
          },
          offset: {
            type: 'number',
            minimum: 0,
            default: 0,
            description: 'Number of tasks to skip'
          }
        },
        required: ['action']
      }
    };
  }

  /**
   * Execute the marshal_tasks tool
   */
  async execute(params: MarshalTasksParams, requestId: string): Promise<TaskMarshalResponse> {
    this._logger.info('Executing marshal_tasks', { 
      action: params.action, 
      requestId,
      hasNaturalLanguage: !!params.naturalLanguage,
      rollbackMode: this.rollbackMode
    });

    try {
      ValidationUtils.validateToolArguments('marshal_tasks', params);

      switch (params.action) {
        case 'create':
          return await this.createTask(params, requestId);
        
        case 'update':
          return await this.updateTask(params, requestId);
        
        case 'assign':
          return await this.assignTask(params, requestId);
        
        case 'complete':
          return await this.completeTask(params, requestId);
        
        case 'analyze':
          return await this.analyzeTasks(params, requestId);
        
        case 'list':
          return await this.listTasks(params, requestId);
        
        default:
          throw new ValidationError(`Invalid action: ${params.action}`);
      }
    } catch (error) {
      this._logger.error('Error executing marshal_tasks', {
        error: error instanceof Error ? error.message : 'Unknown error',
        requestId,
        params,
      });
      throw error;
    }
  }

  private async createTask(params: MarshalTasksParams, requestId: string): Promise<TaskMarshalResponse> {
    if (this.rollbackMode) {
      return await this.createTaskInMemory(params, requestId);
    }

    let taskData: Partial<Task>;

    if (params.naturalLanguage) {
      taskData = await this.parseNaturalLanguageTask(params.naturalLanguage);
    } else if (params.task) {
      taskData = params.task;
    } else {
      throw new ValidationError('Either task data or natural language input is required');
    }

    if (!taskData.initiativeId) {
      throw new ValidationError('initiativeId is required');
    }

    const taskId = uuidv4();
    const task: any = {
      id: taskId,
      title: taskData.title || 'Untitled Task',
      description: taskData.description,
      priority: taskData.priority || 'medium',
      status: 'pending',
      assignee: taskData.assignee,
      dueDate: taskData.dueDate ? new Date(taskData.dueDate) : undefined,
      createdAt: new Date(),
      updatedAt: new Date(),
      tags: taskData.tags || [],
      projectId: taskData.projectId,
      dependencies: taskData.dependencies || [],
      initiativeId: taskData.initiativeId,
      parentTaskId: taskData.parentTaskId || undefined,
      subtasks: [],
      governanceState: 'draft',
      visualPriority: 5,
      insightCards: [],
      narrativeContext: '',
      aiSignals: [],
      metadata: {
        createdBy: 'system',
        requestId,
        source: params.naturalLanguage ? 'natural_language' : 'direct',
      },
    };

    // Validate dependencies
    if (task.dependencies.length > 0) {
      const allTasks = await this.getAllTasks(task.initiativeId);
      const dependencyViolations = await this.validateDependencies(task, allTasks);
      if (dependencyViolations.length > 0) {
        throw new ValidationError('Dependency validation failed', { violations: dependencyViolations });
      }
    }

    await this.journal.append(task.initiativeId, {
      operation: 'create_task',
      initiativeId: task.initiativeId,
      payload: task,
      status: 'pending',
      requestId
    });

    await this.filesystem.writeTask(task);
    await this.journal.markComplete(task.initiativeId, requestId);

    this._logger.info('Task created successfully', { 
      taskId, 
      title: task.title,
      priority: task.priority,
      requestId 
    });

    return {
      success: true,
      data: task,
      metadata: {
        timestamp: new Date(),
        requestId,
        sessionId: params.sessionId,
      },
    };
  }

  private async updateTask(params: MarshalTasksParams, requestId: string): Promise<TaskMarshalResponse> {
    if (this.rollbackMode) {
      return await this.updateTaskInMemory(params, requestId);
    }

    if (!params.task?.id || !params.task?.initiativeId) {
      throw new ValidationError('Task ID and initiativeId are required for update');
    }

    const existingTask = await this.filesystem.readTask(params.task.initiativeId, params.task.id);
    if (!existingTask) {
      throw new NotFoundError('Task', params.task.id);
    }

    const updatedTask: Task = {
      ...existingTask,
      ...params.task,
      id: existingTask.id,
      initiativeId: existingTask.initiativeId,
      updatedAt: new Date(),
      createdAt: existingTask.createdAt,
    };

    // Validate dependencies if changed
    if (updatedTask.dependencies !== existingTask.dependencies) {
      const allTasks = await this.getAllTasks(updatedTask.initiativeId);
      const dependencyViolations = await this.validateDependencies(updatedTask, allTasks);
      if (dependencyViolations.length > 0) {
        throw new ValidationError('Dependency validation failed', { violations: dependencyViolations });
      }
    }

    await this.journal.append(updatedTask.initiativeId, {
      operation: 'update_task',
      initiativeId: updatedTask.initiativeId,
      payload: updatedTask,
      status: 'pending',
      requestId
    });

    await this.filesystem.writeTask(updatedTask);
    await this.journal.markComplete(updatedTask.initiativeId, requestId);

    this._logger.info('Task updated successfully', { 
      taskId: updatedTask.id,
      requestId 
    });

    return {
      success: true,
      data: updatedTask,
      metadata: {
        timestamp: new Date(),
        requestId,
        sessionId: params.sessionId,
      },
    };
  }

  private async assignTask(params: MarshalTasksParams, requestId: string): Promise<TaskMarshalResponse> {
    if (this.rollbackMode) {
      return await this.assignTaskInMemory(params, requestId);
    }

    if (!params.task?.id || !params.task?.initiativeId || !params.task?.assignee) {
      throw new ValidationError('Task ID, initiativeId, and assignee are required for assignment');
    }

    const task = await this.filesystem.readTask(params.task.initiativeId, params.task.id);
    if (!task) {
      throw new NotFoundError('Task', params.task.id);
    }

    task.assignee = params.task.assignee;
    task.updatedAt = new Date();
    task.metadata = {
      ...task.metadata,
      assignedBy: 'system',
      assignedAt: new Date().toISOString(),
    };

    await this.journal.append(task.initiativeId, {
      operation: 'assign_task',
      initiativeId: task.initiativeId,
      payload: task,
      status: 'pending',
      requestId
    });

    await this.filesystem.writeTask(task);
    await this.journal.markComplete(task.initiativeId, requestId);

    this._logger.info('Task assigned successfully', { 
      taskId: task.id,
      assignee: task.assignee,
      requestId 
    });

    return {
      success: true,
      data: task,
      metadata: {
        timestamp: new Date(),
        requestId,
    if (!params.task?.id || !params.task?.initiativeId) {
      throw new ValidationError('Task ID and initiativeId are required for completion');
    }

    const task = this.tasks.get(params.task.id);
    if (!task) throw new NotFoundError('Task', params.task.id);
    }

    // Check if all dependencies are completed
    const dependencies = await this.filesystem.readDependencies(params.task.initiativeId);
    const taskDependencies = dependencies.filter(d => d.to === task.id);
    const allTasks = await this.getAllTasks(task.initiativeId);
    
    const incompleteDependencies = taskDependencies.filter(dep => {
      const depTask = allTasks.find(t => t.id === dep.from);
      return depTask && depTask.status !== 'completed';
    });

    if (incompleteDependencies.length > 0) {
      throw new ValidationError('Cannot complete task with incomplete dependencies', {
        incompleteDependencies: incompleteDependencies.map(d => d.from)
      });
    }

    task.status = 'completed';
    task.updatedAt = new Date();
    task.metadata = {
      ...task.metadata,
      completedBy: 'system',
      completedAt: new Date().toISOString(),
    };

    await this.journal.append(task.initiativeId, {
      operation: 'complete_task',
      initiativeId: task.initiativeId,
      payload: task,
      status: 'pending',
      requestId
    });

    await this.filesystem.writeTask(task);
    await this.journal.markComplete(task.initiativeId, requestId);

    this._logger.info('Task completed successfully', { 
      taskId: task.id,
      requestId 
    });

    return {
      success: true,
      data: task,
      metadata: {
        timestamp: new Date(),
        requestId,
        sessionId: params.sessionId,
      },
    };
  }

  private async analyzeTasks(params: MarshalTasksParams, requestId: string): Promise<TaskMarshalResponse> {
    if (!params.filters?.initiativeId) {
      throw new ValidationError('initiativeId is required for analysis');
    }

    const tasks = await this.getAllTasks(params.filters.initiativeId);
    const dependencies = await this.filesystem.readDependencies(params.filters.initiativeId);
    
    this.dependencies.loadContracts(dependencies);
    
    const cycles = this.dependencies.detectCycles(tasks.map(t => t.id));
    const overdueTasks = this.getOverdueTasks(tasks);
    const upcomingDeadlines = this.getUpcomingDeadlines(tasks);
    
    const analysis = {
      totalTasks: tasks.length,
      byStatus: this.groupByStatus(tasks),
      byPriority: this.groupByPriority(tasks),
      byAssignee: this.groupByAssignee(tasks),
      overdueTasks: overdueTasks.length,
      upcomingDeadlines: upcomingDeadlines.length,
      cycles: cycles.length,
      blockedTasks: tasks.filter(t => this.dependencies.getBlockedTasks(t.id).length > 0).length,
      averageCompletionTime: this.calculateAverageCompletionTime(tasks),
      recommendations: await this.generateRecommendations(tasks, cycles),
    };

    this._logger.info('Task analysis completed', { 
      totalTasks: analysis.totalTasks,
      cycles: analysis.cycles,
      requestId 
    });

    return {
      success: true,
      data: analysis,
      metadata: {
        timestamp: new Date(),
        requestId,
        sessionId: params.sessionId,
      },
    };
  }

  private async listTasks(params: MarshalTasksParams, requestId: string): Promise<TaskMarshalResponse> {
    if (!params.filters?.initiativeId) {
      throw new ValidationError('initiativeId is required for listing tasks');
    }

    const tasks = await this.getAllTasks(params.filters.initiativeId);
    const filteredTasks = this.filterTasks(tasks, params.filters);
    
    const { limit, offset } = ValidationUtils.validatePagination(params.limit, params.offset);
    const paginatedTasks = filteredTasks.slice(offset, offset + limit);

    const response = {
      items: paginatedTasks,
      pagination: {
        total: filteredTasks.length,
        limit,
        offset,
        hasMore: offset + limit < filteredTasks.length,
      },
    };

    this._logger.info('Tasks listed successfully', { 
      totalTasks: filteredTasks.length,
      returnedTasks: paginatedTasks.length,
      requestId 
    });

    return {
      success: true,
      data: response,
      metadata: {
        timestamp: new Date(),
        requestId,
        sessionId: params.sessionId,
      },
    };
  }

  private async getAllTasks(initiativeId: string): Promise<Task[]> {
    if (this.rollbackMode) {
      return Array.from(this.tasks.values()).filter(t => t.initiativeId === initiativeId);
    }
    
    const taskIds = await this.filesystem.listTasks(initiativeId);
    const tasks: Task[] = [];
    
    for (const taskId of taskIds) {
      const task = await this.filesystem.readTask(initiativeId, taskId);
      if (task) tasks.push(task);
    }
    
    return tasks;
  }

  private async validateDependencies(task: Task, allTasks: Task[]): Promise<string[]> {
    const violations: string[] = [];
    
    // Check for cycles
    const contracts: DependencyContract[] = [];
    for (const depId of task.dependencies) {
      contracts.push({
        from: depId,
        to: task.id,
        relationshipType: 'depends-on',
        autonomy: { requiresManualApproval: false }
      });
    }
    
    this.dependencies.loadContracts(contracts);
    const cycles = this.dependencies.detectCycles(allTasks.map(t => t.id));
    if (cycles.length > 0) {
      violations.push('Circular dependencies detected');
    }
    
    // Check chronological order
    const chronologicalViolations = this.dependencies.validateChronologicalOrder(allTasks);
    violations.push(...chronologicalViolations);
    
    return violations;
  }

  private filterTasks(tasks: Task[], filters?: any): Task[] {
    let filtered = tasks;
    
    if (!filters) return filtered;
    
    if (filters.status && filters.status.length > 0) {
      filtered = filtered.filter(task => filters.status.includes(task.status));
    }
    
    if (filters.priority && filters.priority.length > 0) {
      filtered = filtered.filter(task => filters.priority.includes(task.priority));
    }
    
    if (filters.assignee && filters.assignee.length > 0) {
      filtered = filtered.filter(task => task.assignee && filters.assignee.includes(task.assignee));
    }
    
    if (filters.tags && filters.tags.length > 0) {
      filtered = filtered.filter(task => 
        filters.tags.some((tag: string) => task.tags.includes(tag))
      );
    }
    
    return filtered;
  }

  private groupByStatus(tasks: Task[]): Record<string, number> {
    const groups: Record<string, number> = {};
    tasks.forEach(task => {
      groups[task.status] = (groups[task.status] || 0) + 1;
    });
    return groups;
  }

  private groupByPriority(tasks: Task[]): Record<string, number> {
    const groups: Record<string, number> = {};
    tasks.forEach(task => {
      groups[task.priority] = (groups[task.priority] || 0) + 1;
    });
    return groups;
  }

  private groupByAssignee(tasks: Task[]): Record<string, number> {
    const groups: Record<string, number> = {};
    tasks.forEach(task => {
      if (task.assignee) {
        groups[task.assignee] = (groups[task.assignee] || 0) + 1;
      }
    });
    return groups;
  }

  private getOverdueTasks(tasks: Task[]): Task[] {
    const now = new Date();
    return tasks.filter(task => 
      task.dueDate && 
      task.dueDate < now && 
      task.status !== 'completed'
    );
  }

  private getUpcomingDeadlines(tasks: Task[]): Task[] {
    const now = new Date();
    const nextWeek = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
    
    return tasks.filter(task => 
      task.dueDate && 
      task.dueDate > now && 
      task.dueDate <= nextWeek &&
      task.status !== 'completed'
    );
  }

  private calculateAverageCompletionTime(tasks: Task[]): number {
    const completedTasks = tasks.filter(task => task.status === 'completed');
    
    if (completedTasks.length === 0) {
      return 0;
    }
    
    const totalTime = completedTasks.reduce((sum, task) => {
      const completionTime = task.updatedAt.getTime() - task.createdAt.getTime();
      return sum + completionTime;
    }, 0);
    
    return totalTime / completedTasks.length;
  }

  private async generateRecommendations(tasks: Task[], cycles: string[][]): Promise<string[]> {
    const recommendations: string[] = [];
    
    if (cycles.length > 0) {
      recommendations.push(`Found ${cycles.length} circular dependencies that need resolution`);
    }
    
    const overdueTasks = this.getOverdueTasks(tasks);
    if (overdueTasks.length > 0) {
      recommendations.push(`You have ${overdueTasks.length} overdue tasks that need immediate attention`);
    }
    
    const highPriorityTasks = tasks.filter(task => 
      task.priority === 'high' || task.priority === 'critical'
    );
    if (highPriorityTasks.length > 5) {
      recommendations.push('Consider delegating some high-priority tasks to balance workload');
    }
    
    const unassignedTasks = tasks.filter(task => !task.assignee);
    if (unassignedTasks.length > 0) {
      recommendations.push(`${unassignedTasks.length} tasks are unassigned and may need attention`);
    }
    
    const blockedTasks = tasks.filter(t => this.dependencies.getBlockedTasks(t.id).length > 0);
    if (blockedTasks.length > 0) {
      recommendations.push(`${blockedTasks.length} tasks are blocked by dependencies`);
    }
    
    return recommendations;
  }

  // In-memory fallback methods for rollback mode
  private tasks: Map<string, Task> = new Map();





  /**
   * Generate AI-powered recommendations
   */
}
